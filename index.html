<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HowBoutIt Preseason Survivor Pool</title>
  <meta name="description" content="NFL Preseason Survivor Pool — live picks, margins, and draft order.">
  <meta name="theme-color" content="#6d28d9">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="apple-touch-icon" href="icons/icon-192.svg">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Tailwind CSS via Play CDN for rapid styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React and ReactDOM (development builds for easier debugging) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Chart.js for rendering bar charts -->
  <script crossorigin src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Babel Standalone enables JSX in the browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Simple styling overrides -->
  <style>
    body {
      /* fallback background gradient */
      background-image: linear-gradient(to top right, #3730a3, #6d28d9);
      font-family: 'Inter', sans-serif;
      /* Improve text size adjust compatibility */
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    /* Scrollbar styling for nicer look */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.1);
    }
    ::-webkit-scrollbar-thumb {
      background-color: rgba(255,255,255,0.3);
      border-radius: 4px;
    }
    /* Animations */
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes trophy {
      0%, 100% { transform: rotate(-15deg); }
      50% { transform: rotate(15deg); }
    }
    .animate-pulse-slow {
      animation: pulse 3s infinite;
    }
    .animate-fade-in {
      animation: fadeIn 0.5s ease-out;
    }
    .animate-trophy {
      animation: trophy 2s infinite;
      display: inline-block;
    }
    /* Marquee for joke ticker */
    /* Marquee using CSS variables for precise from/to offsets */
    @keyframes marqueeVar {
      0% { transform: translateX(var(--from, 100%)); }
      100% { transform: translateX(var(--to, -100%)); }
    }
    .ticker-track {
      animation-timing-function: linear;
      white-space: nowrap;
      will-change: transform;
    }
    @media (hover: hover) {
      .ticker-track:hover { animation-play-state: paused; }
    }
    /* Glass effect */
    .glass {
      background: rgba(255, 255, 255, 0.1);
      /* Safari fallback */
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    /* Eliminated effect */
    .eliminated {
      position: relative;
      overflow: hidden;
    }
    .eliminated::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, rgba(239, 68, 68, 0.3), transparent);
      z-index: 1;
    }
    .eliminated > * {
      position: relative;
      z-index: 2;
    }
    /* Winner effect */
    .winner-glow {
      box-shadow: 0 0 20px rgba(253, 224, 71, 0.7);
    }
    /* Live game indicator */
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .live-indicator {
      animation: blink 1.5s infinite;
    }
    /* Refresh button animation */
    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    .animate-rotate {
      animation: rotate 1s linear;
    }
    /* Respect reduced motion preferences */
    @media (prefers-reduced-motion: reduce) {
      .animate-fade-in,
      .animate-rotate,
      .animate-pulse-slow,
      .animate-trophy {
        animation: none !important;
      }
    }
  </style>
</head>
<body class="min-h-screen text-white font-sans">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;
    
    // Preseason schedule used for reference
    const preseasonSchedule = [
      {
        week: 1,
        games: [
          { date: '2025-08-07', matchup: 'Indianapolis Colts at Baltimore Ravens', time: '7:00' },
          { date: '2025-08-07', matchup: 'Cincinnati Bengals at Philadelphia Eagles', time: '7:30' },
          { date: '2025-08-07', matchup: 'Las Vegas Raiders at Seattle Seahawks', time: '10:00' },
          { date: '2025-08-08', matchup: 'Detroit Lions at Atlanta Falcons', time: '7:00' },
          { date: '2025-08-08', matchup: 'Cleveland Browns at Carolina Panthers', time: '7:00' },
          { date: '2025-08-08', matchup: 'Washington Commanders at New England Patriots', time: '7:30' },
          { date: '2025-08-09', matchup: 'New York Giants at Buffalo Bills', time: '1:00' },
          { date: '2025-08-09', matchup: 'Houston Texans at Minnesota Vikings', time: '4:00' },
          { date: '2025-08-09', matchup: 'Pittsburgh Steelers at Jacksonville Jaguars', time: '7:00' },
          { date: '2025-08-09', matchup: 'Dallas Cowboys at Los Angeles Rams', time: '7:00' },
          { date: '2025-08-09', matchup: 'Tennessee Titans at Tampa Bay Buccaneers', time: '7:30' },
          { date: '2025-08-09', matchup: 'Kansas City Chiefs at Arizona Cardinals', time: '8:00' },
          { date: '2025-08-09', matchup: 'New York Jets at Green Bay Packers', time: '8:00' },
          { date: '2025-08-09', matchup: 'Denver Broncos at San Francisco 49ers', time: '8:30' },
          { date: '2025-08-10', matchup: 'Miami Dolphins at Chicago Bears', time: '1:00' },
          { date: '2025-08-10', matchup: 'New Orleans Saints at Los Angeles Chargers', time: '4:05' },
        ]
      },
      {
        week: 2,
        games: [
          { date: '2025-08-15', matchup: 'Tennessee Titans at Atlanta Falcons', time: '7:00' },
          { date: '2025-08-15', matchup: 'Kansas City Chiefs at Seattle Seahawks', time: '10:00' },
          { date: '2025-08-16', matchup: 'Miami Dolphins at Detroit Lions', time: '1:00' },
          { date: '2025-08-16', matchup: 'Carolina Panthers at Houston Texans', time: '1:00' },
          { date: '2025-08-16', matchup: 'Green Bay Packers at Indianapolis Colts', time: '1:00' },
          { date: '2025-08-16', matchup: 'New England Patriots at Minnesota Vikings', time: '1:00' },
          { date: '2025-08-16', matchup: 'Cleveland Browns at Philadelphia Eagles', time: '1:00' },
          { date: '2025-08-16', matchup: 'San Francisco 49ers at Las Vegas Raiders', time: '4:00' },
          { date: '2025-08-16', matchup: 'Baltimore Ravens at Dallas Cowboys', time: '7:00' },
          { date: '2025-08-16', matchup: 'Los Angeles Chargers at Los Angeles Rams', time: '7:00' },
          { date: '2025-08-16', matchup: 'New York Jets at New York Giants', time: '7:00' },
          { date: '2025-08-16', matchup: 'Tampa Bay Buccaneers at Pittsburgh Steelers', time: '7:00' },
          { date: '2025-08-16', matchup: 'Arizona Cardinals at Denver Broncos', time: '9:30' },
          { date: '2025-08-17', matchup: 'Jacksonville Jaguars at New Orleans Saints', time: '1:00' },
          { date: '2025-08-17', matchup: 'Buffalo Bills at Chicago Bears', time: '8:00' },
          { date: '2025-08-18', matchup: 'Cincinnati Bengals at Washington Commanders', time: '8:00' },
        ]
      },
      {
        week: 3,
        games: [
          { date: '2025-08-21', matchup: 'Pittsburgh Steelers at Carolina Panthers', time: '7:00' },
          { date: '2025-08-21', matchup: 'New England Patriots at New York Giants', time: '8:00' },
          { date: '2025-08-22', matchup: 'Philadelphia Eagles at New York Jets', time: '7:30' },
          { date: '2025-08-22', matchup: 'Atlanta Falcons at Dallas Cowboys', time: '8:00' },
          { date: '2025-08-22', matchup: 'Minnesota Vikings at Tennessee Titans', time: '8:00' },
          { date: '2025-08-22', matchup: 'Chicago Bears at Kansas City Chiefs', time: '8:20' },
          { date: '2025-08-23', matchup: 'Baltimore Ravens at Washington Commanders', time: '12:00' },
          { date: '2025-08-23', matchup: 'Indianapolis Colts at Cincinnati Bengals', time: '1:00' },
          { date: '2025-08-23', matchup: 'Los Angeles Rams at Cleveland Browns', time: '1:00' },
          { date: '2025-08-23', matchup: 'Houston Texans at Detroit Lions', time: '1:00' },
          { date: '2025-08-23', matchup: 'Denver Broncos at New Orleans Saints', time: '1:00' },
          { date: '2025-08-23', matchup: 'Seattle Seahawks at Green Bay Packers', time: '4:00' },
          { date: '2025-08-23', matchup: 'Jacksonville Jaguars at Miami Dolphins', time: '7:00' },
          { date: '2025-08-23', matchup: 'Buffalo Bills at Tampa Bay Buccaneers', time: '7:30' },
          { date: '2025-08-23', matchup: 'Los Angeles Chargers at San Francisco 49ers', time: '8:30' },
          { date: '2025-08-23', matchup: 'Las Vegas Raiders at Arizona Cardinals', time: '10:00' },
        ]
      }
    ];

    function App() {
      const [managers, setManagers] = useState([]);
      const [games, setGames] = useState([]);
      const [gameResults, setGameResults] = useState({});
      const [loading, setLoading] = useState(true);
      const [lastUpdated, setLastUpdated] = useState('');
      const [refreshing, setRefreshing] = useState(false);
      const [expanded, setExpanded] = useState(new Set()); // which manager cards are expanded on mobile
      const [chartOpen, setChartOpen] = useState(false); // lazy render chart
      const initViewApplied = useRef(false);
      const [openWeeks, setOpenWeeks] = useState(new Set()); // mobile: which schedule weeks are expanded
      const joshAudioRef = useRef(null); // easter egg audio ref
      const jordanAudioRef = useRef(null); // easter egg audio ref for Jordan (GRAVEDIGGER)
      const westonAudioRef = useRef(null); // easter egg audio ref for Weston (DUUUVALL)
      const ryanAudioRef = useRef(null); // easter egg audio ref for Ryan (Opposite of Adults rmx)
      // Global audio mute toggle (persisted)
      const [muted, setMuted] = useState(localStorage.getItem('mutedAudio') === 'true');
      // Breakdown toggles per manager
      const [openBreakdowns, setOpenBreakdowns] = useState(new Set());
      // Public auto-persist controls
      const [autoPersist, setAutoPersist] = useState(localStorage.getItem('autoPersistEnabled') === 'true');
      const [gistIdState, setGistIdState] = useState((localStorage.getItem('gistId') || '').trim());
      const saveDebounceRef = useRef(null);
      const lastSavedHashRef = useRef('');

      // Manual refresh throttling
      const REFRESH_THROTTLE_MS = 15000; // 15s between manual refreshes
      const lastManualRefreshRef = useRef(0);
      const [cooldownMs, setCooldownMs] = useState(0);
      const cooldownTimerRef = useRef(null);

      const handleManualRefresh = () => {
        const now = Date.now();
        const remaining = lastManualRefreshRef.current + REFRESH_THROTTLE_MS - now;
        if (remaining > 0) {
          setCooldownMs(remaining);
          if (!cooldownTimerRef.current) {
            cooldownTimerRef.current = setInterval(() => {
              setCooldownMs((ms) => {
                const next = Math.max(0, ms - 1000);
                if (next === 0 && cooldownTimerRef.current) {
                  clearInterval(cooldownTimerRef.current);
                  cooldownTimerRef.current = null;
                }
                return next;
              });
            }, 1000);
          }
          return;
        }
        lastManualRefreshRef.current = now;
        setCooldownMs(REFRESH_THROTTLE_MS);
        if (!cooldownTimerRef.current) {
          cooldownTimerRef.current = setInterval(() => {
            setCooldownMs((ms) => {
              const next = Math.max(0, ms - 1000);
              if (next === 0 && cooldownTimerRef.current) {
                clearInterval(cooldownTimerRef.current);
                cooldownTimerRef.current = null;
              }
              return next;
            });
          }, 1000);
        }
        loadData();
      };

      // --- Data staleness helpers ---
      const STALE_MINUTES = 10; // consider data stale after 10 minutes without a successful refresh
      const ageMinutes = useMemo(() => {
        if (!lastUpdated) return null;
        const t = Date.parse(lastUpdated);
        if (Number.isNaN(t)) return null;
        const diffMs = Date.now() - t;
        if (diffMs < 0) return 0;
        return Math.floor(diffMs / 60000);
      }, [lastUpdated]);

      // Cleanup: clear refresh cooldown timer on unmount
      useEffect(() => {
        return () => {
          if (cooldownTimerRef.current) {
            clearInterval(cooldownTimerRef.current);
            cooldownTimerRef.current = null;
          }
        };
      }, []);
      const isStale = useMemo(() => ageMinutes === null || ageMinutes > STALE_MINUTES, [ageMinutes]);

      // --- Fetch with retry & exponential backoff (with jitter) ---
      async function fetchWithRetry(url, options = {}, attempts = 5, baseDelay = 1000, factor = 2) {
        let error;
        for (let i = 0; i < attempts; i++) {
          try {
            const res = await fetch(url, options);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res;
          } catch (err) {
            error = err;
            const jitter = Math.random() * 250;
            const delay = baseDelay * Math.pow(factor, i) + jitter;
            await new Promise(r => setTimeout(r, delay));
          }
        }
        throw error || new Error('Fetch failed');
      }

      // --- Easter Egg: Live Joke Ticker (continuous stream) ---
      const tickerWrapRef = useRef(null);
      const tickerTextRef = useRef(null); // first copy of stream for measurement
      const tickerTrackRef = useRef(null);
      const [tickerDuration, setTickerDuration] = useState(20); // seconds
      const jokes = useMemo(() => [
        "Chris (Hello Naber!) — Yo, Chris, 'Hello Naber'? Sounds like you’re tryin’ to flirt with the neighbor’s dog at the BBQ. Like, ‘Hey, Rover, you lookin’ fine in that flea collar, wanna split a Milk-Bone?’ Man, your team’s so soft, it’s like you drafted a roster full of participation trophies and vibes. Bet you’re startin’ a punter in Week 1, yellin’ ‘NABER!’ when he shanks it into the stands.",
        "Josh (S K) — Josh, what’s ‘S K’ stand for? Shitty Kickers? You out here draftin’ guys who miss 20-yard field goals like they’re blindfolded at a carnival game. I bet your team’s game plan is just ‘vibe and cry.’ You’re the dude who shows up to the draft with a Ouija board, tryna summon Tom Brady’s ghost, but all you get is a spectral fumble from Jake Delhomme.",
        "Kevin (Check My Balls) — Kevin, bro, ‘Check My Balls’? You sound like you’re one bad physical away from a malpractice lawsuit. Your team’s probably got more injuries than a Civil War reenactment gone wrong. Like, ‘Yo, doc, check my balls, I think I pulled something carryin’ this L.’ Bet you’re startin’ a third-string tight end who moonlights as an Uber driver. Keep it classy, Kev.",
        "Austin (Honey Baked Lamb) — Austin, ‘Honey Baked Lamb’? What is this, a fantasy team or a hipster butcher shop? You out here servin’ artisanal losses with a side of kale. Bet your draft board’s just a charcuterie spread with Aaron Rodgers’ face carved in prosciutto.",
        "Ryan (Quail Man SWAG) — Ryan, ‘Quail Man SWAG’? Bro, you’re reppin’ a deep-cut Doug Funnie reference like it’s 1996. Your team’s got the swag of a kid who brought a Capri Sun to prom. Bet you’re startin’ a backup RB who fumbles more than a drunk uncle at Thanksgiving.",
        "Weston (Robert DUUUVAL) — Weston, you’re ridin’ for Jacksonville harder than a guy with a mullet and a Natty Light tattoo. Bet you’re prayin’ to the ghost of Blake Bortles to save your season.",
        "Jordan (GRAVEDIGGER) — Jordan, the only thing you’re buryin’ is your playoff hopes. Your roster’s more like a 53-year-old accountant named Randy who pulled a hammy playin’ pickleball.",
        "John (DELTA 8) — John, you sound like you drafted after hittin’ a gas-station vape. Your lineup’s got more gummies than touchdowns. Your WR1 retired in 2017 and you didn’t notice.",
        "Nick (Allen’s Dirty Brown Kupp) — Nick, that name’s so filthy it gets flagged on Craigslist. You’re bankin’ on Cooper Kupp while your WR2 sells bootleg jerseys in Lot B.",
        "William (Just Win Baby) — William, more like ‘Just Lose, Maybe.’ You’re quotin’ Al Davis while your QB throws four picks. Just win? Try just survivin’ the group chat roast."
      ], []);
      // Build continuous stream (initially in given order); click will reshuffle
      const [streamJokes, setStreamJokes] = useState([]);
      useEffect(() => { setStreamJokes(jokes); }, [jokes]);
      const reshuffleStream = React.useCallback(() => {
        const arr = [...jokes];
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
        }
        setStreamJokes(arr);
      }, [jokes]);

      // Helper: recompute marquee metrics and restart animation with consistent speed
      const recomputeTicker = React.useCallback(() => {
        const wrap = tickerWrapRef.current;
        const text = tickerTextRef.current;
        const track = tickerTrackRef.current;
        if (!wrap || !text || !track) return;
        if (text.childElementCount === 0) return; // wait until jokes are rendered
        // Ensure measurement spans are laid out
        const contentW = Math.max(1, text.scrollWidth);
        // Constant reading speed in px/sec (tuned for readability)
        const PX_PER_SEC = 20;
        let seconds = contentW / PX_PER_SEC;
        // Clamp duration to avoid extremes
        seconds = Math.max(35, Math.min(120, seconds));
        setTickerDuration(seconds);
        // Apply CSS variables and restart the animation cleanly
        track.style.setProperty('--from', '0px');
        track.style.setProperty('--to', `-${contentW}px`);
        track.style.animationName = 'none';
        // Force reflow to reset animation
        // eslint-disable-next-line no-unused-expressions
        track.offsetWidth;
        track.style.animationTimingFunction = 'linear';
        track.style.animationDuration = `${seconds}s`;
        track.style.animationIterationCount = 'infinite';
        track.style.animationName = 'marqueeVar';
        track.style.animationPlayState = 'running';
      }, []);

      // Recompute on stream changes and on resize
      useEffect(() => { recomputeTicker(); }, [streamJokes, recomputeTicker]);
      useEffect(() => {
        const onResize = () => recomputeTicker();
        const onVisibility = () => { if (!document.hidden) recomputeTicker(); };
        const onOrient = () => recomputeTicker();
        window.addEventListener('resize', onResize);
        document.addEventListener('visibilitychange', onVisibility);
        window.addEventListener('orientationchange', onOrient);
        return () => {
          window.removeEventListener('resize', onResize);
          document.removeEventListener('visibilitychange', onVisibility);
          window.removeEventListener('orientationchange', onOrient);
        };
      }, [recomputeTicker]);

      // After web fonts load, re-measure and restart if width changed significantly
      useEffect(() => {
        let cancelled = false;
        const wrap = tickerWrapRef.current;
        const text = tickerTextRef.current;
        if (!wrap || !text) return;
        const initialW = text.scrollWidth || 1;
        const recompute = () => {
          if (cancelled) return;
          const newW = text.scrollWidth || 1;
          const delta = Math.abs(newW - initialW);
          if (delta / Math.max(1, initialW) < 0.05) return; // <5% change: ignore
          recomputeTicker();
        };
        // If browser supports font loading API
        if (document.fonts && document.fonts.ready) {
          document.fonts.ready.then(recompute);
        } else {
          // Fallback: wait a tick and re-measure once
          const tid = setTimeout(recompute, 600);
          return () => { cancelled = true; clearTimeout(tid); };
        }
        return () => { cancelled = true; };
      }, [streamJokes, recomputeTicker]);

      // --- Helpers: calendar state from schedule dates ---
      const getWeekRange = (week) => {
        // Use UTC day bounds and generous padding to avoid timezone edge misses
        const startUTC = new Date(week.games[0].date + 'T00:00:00Z');
        const endUTC = new Date(Math.max(...week.games.map(g => new Date(g.date + 'T23:59:59Z').getTime())));
        const pad = 36 * 60 * 60 * 1000; // +/-36h buffer
        const start = new Date(startUTC.getTime() - pad);
        const end = new Date(endUTC.getTime() + pad);
        return { start, end };
      };
      const computeCalendarState = (schedule) => {
        if (!schedule || !schedule.length) return { activeWeek: 1, completedWeeks: 0, totalWeeks: 0 };
        const now = new Date();
        let activeWeek = schedule[0].week;
        let completedWeeks = 0;
        for (let i = 0; i < schedule.length; i++) {
          const w = schedule[i];
          const { start, end } = getWeekRange(w);
          if (now < start) { activeWeek = w.week; break; }
          if (now >= start && now <= end) { activeWeek = w.week; break; }
          // now > end -> completed
          completedWeeks = i + 1;
          activeWeek = w.week; // will end up last if all completed
        }
        return { activeWeek, completedWeeks, totalWeeks: schedule.length };
      };
      
      // Function to load data with cache-busting (prefers Gist via config.json)
      const loadData = async () => {
        setRefreshing(true);
        const timestamp = new Date().getTime();
        // Try to read gistId from config.json
        let gistId = '';
        try {
          const cfgRes = await fetch(`config.json?t=${timestamp}`);
          if (cfgRes.ok) {
            const cfg = await cfgRes.json();
            if (cfg && cfg.gistId) gistId = cfg.gistId.trim();
          }
        } catch (e) {
          // no config found; will fall back below
        }
        // Fallback to localStorage gistId if not in config
        if (!gistId) {
          const lsId = (localStorage.getItem('gistId') || '').trim();
          if (lsId) gistId = lsId;
        }
        setGistIdState(gistId);
        // If gistId configured, try Gist first
        if (gistId) {
          try {
            const metaRes = await fetch(`https://api.github.com/gists/${gistId}`);
            if (!metaRes.ok) throw new Error(`Gist metadata fetch failed: ${metaRes.status}`);
            const meta = await metaRes.json();
            const dataFile = meta.files && (meta.files['data.json'] || meta.files['data.JSON']);
            if (!dataFile || !dataFile.raw_url) throw new Error('data.json not found in Gist');
            const res = await fetch(`${dataFile.raw_url}?t=${timestamp}`);
            if (!res.ok) throw new Error(`Gist raw fetch failed: ${res.status}`);
            const data = await res.json();
            setManagers(data.managers || []);
            setGameResults(data.gameResults || {});
            setLastUpdated(data.lastUpdated || '');
            setLoading(false);
            setRefreshing(false);
            return;
          } catch (err) {
            console.error('Gist load failed, falling back to local data.json:', err);
          }
        }
        // Fallback to local data.json
        try {
          const response = await fetch(`data.json?t=${timestamp}`);
          const data = await response.json();
          setManagers(data.managers || []);
          setGameResults(data.gameResults || {});
          setLastUpdated(data.lastUpdated || '');
          setLoading(false);
          setRefreshing(false);
        } catch (error) {
          console.error('Error loading data:', error);
          setLoading(false);
          setRefreshing(false);
        }
      };
      
      // Initial data load
      useEffect(() => {
        loadData();
      }, []);

      // Persist autoPersist preference locally
      useEffect(() => {
        localStorage.setItem('autoPersistEnabled', autoPersist ? 'true' : 'false');
      }, [autoPersist]);

      // Persist mute preference locally
      useEffect(() => {
        localStorage.setItem('mutedAudio', muted ? 'true' : 'false');
      }, [muted]);

      // When muting, pause any currently playing easter egg audio
      useEffect(() => {
        if (muted) {
          try { pauseAllEggs(); } catch (e) {}
        }
      }, [muted]);

      // Fetch scores periodically from ESPN and calculate margins
      useEffect(() => {
        let cancelled = false;
        async function fetchScores() {
          try {
            const res = await fetchWithRetry('https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard', {}, 5, 1000, 2);
            const data = await res.json();
            if (!cancelled) {
              setGames(data.events || []);
              // Only bump lastUpdated on successful scoreboard fetch
              setLastUpdated(new Date().toISOString());
              
              // Calculate margins and results for managers' picks
              if (data.events && data.events.length > 0) {
                calculateAndUpdateFromScores(data.events);
              }
            }
          } catch (err) {
            console.error('Error fetching scores (after retries):', err);
            // Do not update lastUpdated here; allows stale indicator to surface
          }
        }
        
        // Calculate margins and results based on game scores
        const calculateAndUpdateFromScores = (games) => {
          const updatedManagers = managers.map(manager => {
            let newMarginOfVictory = 0;
            let hasUpdatedPick = false;
            let newPicks = [...manager.picks];
            
            // Check each week's pick
            manager.picks.forEach((pick, weekIndex) => {
              if (pick.team) {
                // Find the game involving this team
                const game = games.find(g => {
                  const comp = g.competitions && g.competitions[0];
                  if (!comp) return false;
                  const teams = comp.competitors;
                  const home = teams.find(t => t.homeAway === 'home');
                  const away = teams.find(t => t.homeAway === 'away');
                  return (home && home.team.displayName === pick.team) ||
                         (away && away.team.displayName === pick.team);
                });
                
                if (game && game.competitions && game.competitions[0]) {
                  const comp = game.competitions[0];
                  const teams = comp.competitors;
                  const home = teams.find(t => t.homeAway === 'home');
                  const away = teams.find(t => t.homeAway === 'away');
                  const status = game.status && game.status.type && game.status.type.state;
                  
                  if (home && away && home.score !== undefined && away.score !== undefined) {
                    // Calculate margin based on which team was picked
                    let margin = 0;
                    if (home.team.displayName === pick.team) {
                      margin = home.score - away.score;
                    } else {
                      margin = away.score - home.score;
                    }
                    
                    // Determine if the team won, lost, or tied
                    let result = null;
                    if (margin > 0) result = 'W';
                    else if (margin < 0) result = 'L';
                    else result = null; // tie -> no W/L
                    
                    // Only auto-update if the game is completed and this pick is not a manual override
                    if (status === 'post' && !pick.manualResult) {
                      const nextPick = {
                        ...pick,
                        margin: margin,
                        manualResult: false, // Mark as automatic result
                        lastUpdated: new Date().toISOString()
                      };
                      if (result !== null) nextPick.result = result; else delete nextPick.result;
                      if (pick.result !== result || pick.margin !== margin) {
                        newPicks[weekIndex] = nextPick;
                        hasUpdatedPick = true;
                      }
                    }
                  }
                }
              }
            });
            
            // Recompute total margin strictly from stored pick.margin values where result === 'W'
            newMarginOfVictory = newPicks.reduce((sum, p) => sum + ((p.result === 'W' && typeof p.margin === 'number') ? p.margin : 0), 0);

            // Update manager if we found valid scores or margin changed
            if (hasUpdatedPick || newMarginOfVictory !== manager.marginOfVictory) {
              return {
                ...manager,
                picks: newPicks,
                marginOfVictory: newMarginOfVictory,
                eliminated: newPicks.some(p => p.result === 'L')
              };
            }
            
            return manager;
          });
          
          // Update state if anything changed
          if (JSON.stringify(updatedManagers) !== JSON.stringify(managers)) {
            setManagers(updatedManagers);
            // Also bump lastUpdated when managers are modified due to live data
            setLastUpdated(new Date().toISOString());
          }
        };
        
        // Initial fetch
        fetchScores();
        // Poll every 2 minutes
        const intervalId = setInterval(fetchScores, 2 * 60 * 1000);
        return () => {
          cancelled = true;
          clearInterval(intervalId);
        };
      }, [managers]);

      // Map outcomes by team for elimination/margin derivation
      const teamOutcomeMap = useMemo(() => {
        const map = new Map();
        if (!games || !games.length) return map;
        games.forEach(ev => {
          const comp = ev.competitions && ev.competitions[0];
          if (!comp) return;
          const teams = comp.competitors || [];
          const home = teams.find(t => t.homeAway === 'home');
          const away = teams.find(t => t.homeAway === 'away');
          if (!home || !away) return;
          const state = ev.status && ev.status.type && ev.status.type.state;
          const homeScore = Number(home.score || 0);
          const awayScore = Number(away.score || 0);
          const isTie = state === 'post' && homeScore === awayScore;
          map.set(home.team.displayName, { state, isWinner: homeScore > awayScore, isTie, score: homeScore, oppScore: awayScore });
          map.set(away.team.displayName, { state, isWinner: awayScore > homeScore, isTie, score: awayScore, oppScore: homeScore });
        });
        return map;
      }, [games]);

      // Outcome helper for a specific week window (prevents future-week picks from inheriting past results)
      const getTeamOutcomeForWeek = (teamName, weekNumber) => {
        const wk = Number(weekNumber);
        if (!teamName || !wk || !games || !games.length) return null;
        const weekData = preseasonSchedule.find(w => Number(w.week) === wk);
        if (!weekData) return null;
        const { start, end } = getWeekRange(weekData);
        for (const ev of games) {
          const evDate = ev.date ? new Date(ev.date) : null;
          if (!evDate || evDate < start || evDate > end) continue;
          const comp = ev.competitions && ev.competitions[0];
          if (!comp) continue;
          const teams = comp.competitors || [];
          const home = teams.find(t => t.homeAway === 'home');
          const away = teams.find(t => t.homeAway === 'away');
          if (!home || !away) continue;
          const match = (home.team && home.team.displayName === teamName) || (away.team && away.team.displayName === teamName);
          if (!match) continue;
          const state = ev.status && ev.status.type && ev.status.type.state;
          const homeScore = Number(home.score || 0);
          const awayScore = Number(away.score || 0);
          const isTie = state === 'post' && homeScore === awayScore;
          if (home.team.displayName === teamName) {
            return { state, isWinner: homeScore > awayScore, isTie, score: homeScore, oppScore: awayScore };
          } else {
            return { state, isWinner: awayScore > homeScore, isTie, score: awayScore, oppScore: homeScore };
          }
        }
        return null;
      };

      // Helper: find the schedule matchup string for a team in a given week
      const findMatchupForTeam = (weekNumber, teamName) => {
        const wk = Number(weekNumber);
        if (!wk || !teamName) return null;
        const w = preseasonSchedule.find(x => Number(x.week) === wk);
        if (!w || !Array.isArray(w.games)) return null;
        for (const g of w.games) {
          const [away, home] = (g.matchup || '').split(' at ');
          if (away === teamName || home === teamName) return g.matchup;
        }
        return null;
      };

      // Helper: read stored game result (including optional note) from gameResults by week/matchup
      const getStoredGame = (weekNumber, matchup) => {
        const wk = Number(weekNumber);
        if (!wk || !matchup) return null;
        const key = `week${wk}`;
        const arr = gameResults && gameResults[key];
        if (!Array.isArray(arr)) return null;
        return arr.find(g => g && g.matchup === matchup) || null;
      };

      // Helper: determine if a pick is locked based on live state or scheduled kickoff (ET)
      const isPickLocked = (weekNumber, teamName) => {
        if (!weekNumber || !teamName) return false;
        const outcome = getTeamOutcomeForWeek(teamName, weekNumber);
        if (outcome) {
          return outcome.state && outcome.state !== 'pre';
        }
        // Fallback to schedule kickoff if no live event found
        const w = preseasonSchedule.find(x => Number(x.week) === Number(weekNumber));
        if (!w) return false;
        const g = w.games.find(gg => {
          const [away, home] = (gg.matchup || '').split(' at ');
          return away === teamName || home === teamName;
        });
        if (!g) return false;
        // Assume ET in August (DST -04:00). Times provided without am/pm are typical PM kickoff; treat as local ET clock time.
        // Construct an ET-like timestamp explicitly.
        const timeStr = (g.time || '00:00').padStart(5, '0');
        const dt = new Date(`${g.date}T${timeStr}:00-04:00`);
        return Date.now() >= dt.getTime();
      };

      /**
       * Calculate elimination week and draft order
       */
      // Helper to derive elimination and week even if picks weren't persisted yet
      const deriveElimination = (mgr) => {
        // Buyback override: allow manager to continue despite a recorded loss
        if (mgr && mgr.buyback === true) {
          return { isEliminated: false, week: null };
        }
        // Prefer LIVE outcomes: if any completed game is a non-tie loss for the picked team, eliminated.
        for (const p of (mgr.picks || [])) {
          if (!p.team) continue;
          const outcome = getTeamOutcomeForWeek(p.team, p.week);
          if (outcome && outcome.state === 'post' && !outcome.isWinner && !outcome.isTie) {
            return { isEliminated: true, week: p.week };
          }
        }
        // Fallback to stored explicit losses only if no live completed outcome available
        const lossPick = (mgr.picks || []).find(p => p.result === 'L');
        if (lossPick) return { isEliminated: true, week: lossPick.week };
        return { isEliminated: false, week: null };
      };

      // Margin for a specific week. Prefer LIVE final score margin when available,
      // otherwise fall back to stored pick.margin. Positive when the picked team leads.
      const getWeekMargin = (mgr, week) => {
        // Buyback carry margin: use fixed margin if provided (e.g., -7)
        if (mgr && mgr.buyback === true && typeof mgr.carryMargin === 'number') {
          return mgr.carryMargin;
        }
        const wk = Number(week);
        if (!wk) return 0;
        const pick = (mgr.picks || []).find(p => Number(p.week) === wk);
        if (!pick) return 0;
        if (pick.team) {
          const outcome = getTeamOutcomeForWeek(pick.team, wk);
          // Use live final margin if the game is completed
          if (outcome && outcome.state === 'post') {
            return (outcome.score - outcome.oppScore) || 0;
          }
        }
        // Fallback to stored margin if present (covers manual overrides or persisted results)
        if (typeof pick.margin === 'number') return pick.margin;
        return 0;
      };

      // Calculate cumulative margin from all winning weeks (live-reactive)
      const getCumulativeMargin = (mgr) => {
        if (!mgr || !mgr.picks) return 0;
        
        // Buyback carry margin: use fixed margin if provided (e.g., from previous wins before buyback)
        // Also check for legacy -7 margin for Cincinnati Bengals loss (Ryan's case)
        if (mgr && mgr.buyback === true && typeof mgr.carryMargin === 'number') {
          return mgr.carryMargin;
        }
        
        // For managers who bought back but don't have carryMargin set, check for Cincinnati Bengals loss
        if (mgr && mgr.buyback === true) {
          const bengalsLoss = (mgr.picks || []).find(p => p.team === 'Cincinnati Bengals');
          if (bengalsLoss) {
            return -7; // Known margin for Cincinnati Bengals loss in Week 1
          }
        }
        
        let totalMargin = 0;
        const derived = deriveElimination(mgr);
        
        // For eliminated managers, include wins up to elimination week
        // AND include the elimination-week loss margin (negative).
        if (derived.isEliminated) {
          const elimWeekNum = Number(derived.week);
          for (const pick of mgr.picks) {
            const wk = Number(pick.week);
            if (!wk || !pick.team) continue;
            if (wk > elimWeekNum) continue;

            const outcome = getTeamOutcomeForWeek(pick.team, wk);
            let margin = 0;
            let isWin = false;
            let isLoss = false;

            if (outcome && outcome.state === 'post') {
              const diff = (outcome.score - outcome.oppScore) || 0; // perspective = picked team
              isWin = outcome.isWinner && !outcome.isTie;
              isLoss = !outcome.isWinner && !outcome.isTie;
              margin = diff;
            } else {
              if (typeof pick.margin === 'number') margin = pick.margin;
              isWin = pick.result === 'W';
              isLoss = pick.result === 'L';
            }

            if (isWin) {
              totalMargin += Math.max(0, margin);
            } else if (isLoss && wk === elimWeekNum) {
              // Add the negative loss margin from the elimination week
              totalMargin += Math.min(0, margin);
            }
          }
          return totalMargin;
        }
        
        // For active managers, calculate cumulative wins
        for (const pick of mgr.picks) {
          const wk = Number(pick.week);
          if (!wk || !pick.team) continue;
          
          // Check if this pick is a win (prefer live final over stored result)
          const outcome = getTeamOutcomeForWeek(pick.team, wk);
          let isWin = false;
          let margin = 0;
          
          if (outcome && outcome.state === 'post') {
            // Use live final result and margin
            isWin = outcome.isWinner && !outcome.isTie;
            margin = isWin ? ((outcome.score - outcome.oppScore) || 0) : 0;
          } else {
            // Fallback to stored result and margin
            isWin = pick.result === 'W';
            margin = (isWin && typeof pick.margin === 'number') ? pick.margin : 0;
          }
          
          if (isWin) {
            totalMargin += margin;
          }
        }
        return totalMargin;
      };

      // Build a concise week-by-week margin breakdown matching getCumulativeMargin rules
      const getMarginBreakdown = (mgr) => {
        if (!mgr || !Array.isArray(mgr.picks)) return 'No data';
        const derived = deriveElimination(mgr);
        const elimWeekNum = derived.isEliminated ? Number(derived.week) : null;
        const picksSorted = mgr.picks.slice().sort((a,b) => (Number(a.week||0) - Number(b.week||0)));
        let total = 0;
        const lines = [];
        for (const pick of picksSorted) {
          const wk = Number(pick.week);
          if (!wk || !pick.team) continue;
          if (elimWeekNum && wk > elimWeekNum) continue;
          const outcome = getTeamOutcomeForWeek(pick.team, wk);
          let isTie = false, isWin = false, isLoss = false, diff = 0;
          if (outcome && outcome.state === 'post') {
            diff = (outcome.score - outcome.oppScore) || 0;
            isTie = !!outcome.isTie;
            isWin = outcome.isWinner && !isTie;
            isLoss = !outcome.isWinner && !isTie;
          } else {
            if (typeof pick.margin === 'number') diff = pick.margin;
            isWin = pick.result === 'W';
            isLoss = pick.result === 'L';
            isTie = pick.result === 'T';
          }
          if (derived.isEliminated) {
            if (isWin) {
              total += Math.max(0, diff);
              lines.push(`W${wk} ${pick.team}: +${Math.max(0, diff)}`);
            } else if (isLoss && wk === elimWeekNum) {
              total += Math.min(0, diff);
              lines.push(`W${wk} ${pick.team}: ${Math.min(0, diff)}`);
            }
          } else {
            if (isWin) {
              total += Math.max(0, diff);
              lines.push(`W${wk} ${pick.team}: +${Math.max(0, diff)}`);
            }
          }
        }
        if (lines.length === 0) return 'No completed margins yet';
        lines.push(`Total: ${total}`);
        return lines.join('\n');
      };

      // Draft order per provided rules (live-reactive)
      const computeDraftOrderLive = (mgrs) => {
        const totalWeeks = preseasonSchedule.length || 0;
        const { activeWeek } = computeCalendarState(preseasonSchedule);
        const withKeys = mgrs.map(mgr => {
          const derived = deriveElimination(mgr);
          const eliminationWeek = derived.isEliminated ? Number(derived.week) : (totalWeeks + 1); // survivors rank highest
          // For survivors, use the CURRENT active week's margin to rank winners of completed games above others
          const tieWeek = derived.isEliminated ? Number(derived.week) : Number(activeWeek);
          const weekMargin = getWeekMargin(mgr, tieWeek);
          const cumulativeMargin = getCumulativeMargin(mgr);
          return { ...mgr, eliminationWeek, weekMargin, cumulativeMargin };
        });
        return withKeys
          .sort((a, b) => {
            // 1) Later elimination week first (survivors have totalWeeks+1)
            if (a.eliminationWeek !== b.eliminationWeek) return b.eliminationWeek - a.eliminationWeek;
            // 2) Larger cumulative margin higher (primary tiebreaker)
            if (a.cumulativeMargin !== b.cumulativeMargin) return b.cumulativeMargin - a.cumulativeMargin;
            // 3) Larger week margin higher (secondary tiebreaker for current week performance)
            if (a.weekMargin !== b.weekMargin) return b.weekMargin - a.weekMargin;
            // 4) Better last year rank (smaller number is better)
            return a.lastYearRank - b.lastYearRank;
          })
          .map((mgr, idx) => ({ ...mgr, draftOrder: idx + 1 }));
      };

      const orderedManagers = useMemo(() => computeDraftOrderLive(managers), [managers, games, preseasonSchedule]);

      // Public-side Gist save (opt-in). Uses gistId from config/localStorage and gistToken from localStorage.
      const saveToGistPublic = async (jsonStr) => {
        const id = (gistIdState || localStorage.getItem('gistId') || '').trim();
        const token = (localStorage.getItem('gistToken') || '').trim();
        if (!id || !token) {
          console.warn('Auto-save skipped: missing Gist credentials');
          return;
        }
        try {
          const payload = { files: { 'data.json': { content: jsonStr } } };
          const res = await fetch(`https://api.github.com/gists/${id}`, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `token ${token}`
            },
            body: JSON.stringify(payload)
          });
          if (!res.ok) {
            const t = await res.text();
            throw new Error(`Gist save failed: ${res.status} ${t}`);
          }
          console.log('Auto-saved live results to Gist');
        } catch (err) {
          console.error('Auto-save to Gist failed:', err);
        }
      };

      // Debounced auto-persist when managers change and toggle is enabled
      useEffect(() => {
        if (!autoPersist) return;
        const id = (gistIdState || localStorage.getItem('gistId') || '').trim();
        const token = (localStorage.getItem('gistToken') || '').trim();
        if (!id || !token) return;
        const payloadObj = { managers, lastUpdated: new Date().toISOString() };
        const payloadStr = JSON.stringify(payloadObj, null, 2);
        if (lastSavedHashRef.current === payloadStr) return;
        if (saveDebounceRef.current) clearTimeout(saveDebounceRef.current);
        saveDebounceRef.current = setTimeout(async () => {
          await saveToGistPublic(payloadStr);
          lastSavedHashRef.current = payloadStr;
        }, 3000);
        return () => {
          if (saveDebounceRef.current) {
            clearTimeout(saveDebounceRef.current);
            saveDebounceRef.current = null;
          }
        };
      }, [managers, autoPersist, gistIdState]);
      // Initialize mobile/desktop defaults for expansions and chart section ONCE after data loads
      useEffect(() => {
        if (initViewApplied.current) return;
        if (managers.length === 0) return; // wait for first data load
        const isDesktop = window.matchMedia('(min-width: 768px)').matches; // md breakpoint
        if (isDesktop) {
          setExpanded(new Set(managers.map(m => m.name)));
          setChartOpen(true);
        } else {
          setExpanded(new Set());
          setChartOpen(false);
        }
        initViewApplied.current = true;
      }, [managers.length]);

      // Initialize mobile schedule week groups (open only active week) once schedule is loaded
      useEffect(() => {
        if (!preseasonSchedule || !preseasonSchedule.length) return;
        if (openWeeks.size > 0) return; // don't override user toggles
        const { activeWeek } = computeCalendarState(preseasonSchedule);
        setOpenWeeks(new Set([activeWeek]));
      }, [preseasonSchedule]);

      // No search/filtering — show all managers in draft order
      const filteredManagers = orderedManagers;

      const toggleExpand = (name) => {
        setExpanded(prev => {
          const next = new Set(prev);
          if (next.has(name)) next.delete(name); else next.add(name);
          return next;
        });
      };
      const toggleWeek = (weekNum) => {
        setOpenWeeks(prev => {
          const next = new Set(prev);
          if (next.has(weekNum)) next.delete(weekNum); else next.add(weekNum);
          return next;
        });
      };
      const toggleBreakdown = (name) => {
        setOpenBreakdowns(prev => {
          const next = new Set(prev);
          if (next.has(name)) next.delete(name); else next.add(name);
          return next;
        });
      };
      // Pause all easter egg audios before playing another
      const pauseAllEggs = () => {
        [joshAudioRef, jordanAudioRef, westonAudioRef, ryanAudioRef].forEach(ref => {
          try { if (ref && ref.current) ref.current.pause(); } catch (e) {}
        });
      };
      // Persist mute preference locally
      useEffect(() => {
        localStorage.setItem('mutedAudio', muted ? 'true' : 'false');
      }, [muted]);
      // When muting, pause any currently playing easter egg audio
      useEffect(() => {
        if (muted) {
          try { pauseAllEggs(); } catch (e) {}
        }
      }, [muted]);
      const handleCardClick = (mgr) => {
        if (!mgr || !mgr.name) return;
        // Respect global mute on mobile/desktop
        if (muted) return;
        // Ryan easter egg
        if (mgr.name.trim().toLowerCase() === 'ryan' && ryanAudioRef.current) {
          try {
            pauseAllEggs();
            ryanAudioRef.current.currentTime = 0;
            ryanAudioRef.current.play();
          } catch (e) {
            console.warn('Ryan easter egg audio failed to play:', e);
          }
          return;
        }
        if (mgr.name.trim().toLowerCase() === 'josh' && joshAudioRef.current) {
          try {
            // stop other audio if playing
            pauseAllEggs();
            joshAudioRef.current.currentTime = 0;
            joshAudioRef.current.play();
          } catch (e) {
            console.warn('Easter egg audio failed to play:', e);
          }
          return;
        }
        // Weston easter egg: trigger on name or team label containing "DUUUVALL"
        const isWeston = mgr.name.trim().toLowerCase() === 'weston';
        const labelLower = (mgr.teamLabel || '').trim().toLowerCase();
        const isDuuuval = labelLower.includes('duuuval');
        if ((isWeston || isDuuuval) && westonAudioRef.current) {
          try {
            pauseAllEggs();
            westonAudioRef.current.currentTime = 0;
            westonAudioRef.current.play();
          } catch (e) {
            console.warn('Weston easter egg audio failed to play:', e);
          }
          return;
        }
        // Jordan easter egg: trigger on name or team label "GRAVEDIGGER"
        const isJordan = mgr.name.trim().toLowerCase() === 'jordan';
        const isGraveDigger = (mgr.teamLabel || '').trim().toLowerCase() === 'gravedigger';
        if ((isJordan || isGraveDigger) && jordanAudioRef.current) {
          try {
            pauseAllEggs();
            jordanAudioRef.current.currentTime = 0;
            jordanAudioRef.current.play();
          } catch (e) {
            console.warn('Jordan easter egg audio failed to play:', e);
          }
          return;
        }
      };
      // Memoized calendar snapshot for renders
      const calendar = React.useMemo(() => computeCalendarState(preseasonSchedule), [preseasonSchedule, lastUpdated]);
      // Build data for bar chart
      const chartData = useMemo(() => {
        return (managers || []).map(mgr => {
          let wins = 0;
          let eliminated = false;
          const picksSorted = [...(mgr.picks || [])].sort((a, b) => Number(a.week) - Number(b.week));
          for (const p of picksSorted) {
            const wk = Number(p && p.week);
            if (!wk || eliminated) continue;
            const team = p.team;
            if (team) {
              const out = getTeamOutcomeForWeek(team, wk);
              if (out && out.state === 'post') {
                if (out.isTie) continue; // ties neither win nor eliminate
                if (out.isWinner) {
                  wins += 1;
                } else {
                  eliminated = true;
                }
                continue;
              }
            }
            // Fallback to stored result only if no live final and week has ended
            const wd = preseasonSchedule.find(w => Number(w.week) === wk);
            if (wd) {
              const { end } = getWeekRange(wd);
              if (end && end.getTime() <= Date.now()) {
                if (p.result === 'W') wins += 1;
                else if (p.result === 'L') { eliminated = true; }
              }
            }
          }
          return { name: mgr.name, wins };
        });
      }, [managers, games, preseasonSchedule]);

      // Map of scoreboard by matchup string and sorted events for display
      const scoreboardMap = useMemo(() => {
        const map = new Map();
        if (!games || !games.length) return map;
        games.forEach(ev => {
          const comp = ev.competitions && ev.competitions[0];
          if (!comp) return;
          const teams = comp.competitors || [];
          const home = teams.find(t => t.homeAway === 'home');
          const away = teams.find(t => t.homeAway === 'away');
          if (!home || !away) return;
          const key = `${away.team.displayName} at ${home.team.displayName}`;
          const state = ev.status && ev.status.type && ev.status.type.state;
          map.set(key, {
            state,
            awayScore: Number(away.score || 0),
            homeScore: Number(home.score || 0),
            date: ev.date ? new Date(ev.date) : null,
          });
        });
        return map;
      }, [games]);

      const gamesSorted = useMemo(() => {
        if (!games || !games.length) return [];
        const rank = (state) => state === 'in' ? 0 : (state === 'pre' ? 1 : 2);
        return [...games].sort((a, b) => {
          const sa = a.status && a.status.type && a.status.type.state;
          const sb = b.status && b.status.type && b.status.type.state;
          const ra = rank(sa);
          const rb = rank(sb);
          if (ra !== rb) return ra - rb;
          const da = a.date ? new Date(a.date).getTime() : 0;
          const db = b.date ? new Date(b.date).getTime() : 0;
          return da - db;
        });
      }, [games]);

      // Chart.js reference
      const chartRef = useRef(null);
      const chartInstance = useRef(null);
      const prevChartSigRef = useRef('');

      // Render or update the bar chart (lazy when chartOpen)
      useEffect(() => {
        if (!chartOpen) {
          if (chartInstance.current) {
            chartInstance.current.destroy();
            chartInstance.current = null;
            prevChartSigRef.current = '';
          }
          return;
        }
        if (!chartRef.current || chartData.length === 0) return;
        const ctx = chartRef.current.getContext('2d');

        const labels = chartData.map(item => item.name);
        const data = chartData.map(item => Number(item.wins) || 0);
        const signature = JSON.stringify({ labels, data });
        const maxValue = data.length ? Math.max(...data) : 0;
        const weeksCap = (preseasonSchedule && preseasonSchedule.length) || 3;
        const yMax = Math.max(1, weeksCap, maxValue);

        if (!chartInstance.current) {
          // Create chart once
          chartInstance.current = new Chart(ctx, {
            type: 'bar',
            data: {
              labels,
              datasets: [
                {
                  label: 'Survived Weeks',
                  data,
                  backgroundColor: 'rgba(99, 102, 241, 0.7)',
                  borderColor: 'rgba(99, 102, 241, 1)',
                  borderWidth: 0,
                  borderRadius: 5
                }
              ]
            },
            options: {
              animation: false,
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  ticks: { color: '#fff', font: { size: 12 } },
                  grid: { display: false }
                },
                y: {
                  beginAtZero: true,
                  max: yMax,
                  ticks: {
                    color: '#fff',
                    font: { size: 12 },
                    stepSize: 1,
                    callback: function(value) { return value; }
                  },
                  grid: { color: 'rgba(255, 255, 255, 0.2)' }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    color: '#fff'
                  }
                },
                tooltip: {
                  backgroundColor: 'rgba(255,255,255,0.9)',
                  titleColor: '#000',
                  bodyColor: '#000',
                  borderColor: 'rgba(0,0,0,0.1)',
                  borderWidth: 1,
                  callbacks: {
                    label: function(context) {
                      return `Survived: ${context.raw} week${context.raw !== 1 ? 's' : ''}`;
                    }
                  }
                }
              }
            }
          });
          
          prevChartSigRef.current = signature;
          return;
        }

        // Update existing chart only when data/labels actually change
        if (prevChartSigRef.current !== signature) {
          const chart = chartInstance.current;
          chart.data.labels = labels;
          chart.data.datasets[0].data = data;
          if (chart.options && chart.options.scales && chart.options.scales.y) {
            chart.options.scales.y.max = yMax;
          }
          chart.update('none');
          prevChartSigRef.current = signature;
        } else {
          // Keep yMax in sync even if data unchanged
          const chart = chartInstance.current;
          if (chart && chart.options && chart.options.scales && chart.options.scales.y) {
            chart.options.scales.y.max = yMax;
          }
        }

        // Cleanup
        return () => {
          // Do not destroy here; only when chartOpen flips to false or component unmounts
        };
      }, [chartOpen, chartData, preseasonSchedule]);

      if (loading) {
        return (
          <div className="flex items-center justify-center min-h-screen">
            <div className="text-center">
              <div className="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-purple-500 mx-auto"></div>
              <p className="mt-4 text-xl">Loading Survivor Pool...</p>
            </div>
          </div>
        );
      }

      return (
        <div className="p-4 space-y-6 max-w-7xl mx-auto">
          {/* Easter egg audio (hidden) */}
          <audio ref={joshAudioRef} src="Audio/ImACop.mp3" preload="none" muted={muted} style={{ display: 'none' }} />
          <audio ref={jordanAudioRef} src="Audio/GraveDigger.mp3" preload="none" muted={muted} style={{ display: 'none' }} />
          <audio ref={westonAudioRef} src="Audio/Duuuval.mp3" preload="none" muted={muted} style={{ display: 'none' }} />
          <audio ref={ryanAudioRef} src="Audio/Opposite of Adults rmx.mp3" preload="none" muted={muted} style={{ display: 'none' }} />
          {/* Sticky Toolbar */}
          <div
            className="sticky top-0 z-50 glass rounded-xl px-3 py-2 -mx-1 md:mx-0 backdrop-blur animate-fade-in"
            style={{ paddingTop: 'calc(0.5rem + env(safe-area-inset-top))' }}
          >
            <div className="flex items-center justify-between gap-3">
              <div className="text-xs text-purple-200 whitespace-nowrap flex items-center gap-2">
                <span>Last updated: {lastUpdated ? new Date(lastUpdated).toLocaleString() : '—'}</span>
                {isStale && (
                  <span className="px-2 py-0.5 rounded-full bg-amber-400 text-black font-bold text-[10px]" title="Live data may be out of date">STALE</span>
                )}
              </div>
              <div className="flex items-center gap-3">
                <label className="hidden sm:flex items-center gap-2 text-xs select-none" title="Automatically save live results to your configured Gist">
                  <input
                    type="checkbox"
                    checked={autoPersist}
                    onChange={(e) => setAutoPersist(e.target.checked)}
                    aria-label="Enable auto-save to Gist"
                    className="h-4 w-4 rounded border-purple-400 bg-transparent"
                  />
                  Auto-save to Gist
                </label>
                {/* Global mute toggle (mobile only) */}
                <button
                  onClick={() => setMuted(m => !m)}
                  aria-label={muted ? 'Unmute sounds' : 'Mute sounds'}
                  className={`inline-flex md:hidden items-center justify-center p-2.5 rounded-full ${muted ? 'bg-gray-600' : 'bg-purple-600 hover:bg-purple-700'} transition-colors`}
                  title={muted ? 'Unmute' : 'Mute'}
                >
                  <i className={`fas ${muted ? 'fa-volume-mute' : 'fa-volume-up'}`}></i>
                </button>
                <button
                  onClick={() => setMuted(m => !m)}
                  aria-label={muted ? 'Unmute audio' : 'Mute audio'}
                  className={`hidden md:inline-flex items-center justify-center p-2.5 rounded-full ${muted ? 'bg-gray-600' : 'bg-purple-600 hover:bg-purple-700'} transition-colors`}
                  title={muted ? 'Audio muted' : 'Audio on'}
                >
                  <i className={`fas ${muted ? 'fa-volume-xmark' : 'fa-volume-high'}`}></i>
                </button>
                <button
                  onClick={handleManualRefresh}
                  disabled={refreshing || loading || cooldownMs > 0}
                  aria-label="Refresh data"
                  aria-busy={refreshing}
                  className={`hidden md:inline-flex items-center justify-center p-2.5 rounded-full ${(refreshing || cooldownMs > 0) ? 'bg-gray-600' : 'bg-purple-600 hover:bg-purple-700'} transition-colors`}
                  title={`Refresh data${cooldownMs > 0 ? ` (wait ${Math.ceil(cooldownMs/1000)}s)` : ''}`}
                >
                  <i className={`fas fa-sync-alt ${refreshing ? 'animate-rotate' : ''}`}></i>
                </button>
              </div>
            </div>
          </div>

          {/* Stale data banner */}
          {isStale && (
            <div className="mt-2 glass rounded-lg px-3 py-2 -mx-1 md:mx-0 border border-amber-400/40 text-amber-200 flex items-center gap-2 animate-fade-in" role="status" aria-live="polite">
              <i className="fas fa-triangle-exclamation text-amber-300" aria-hidden="true"></i>
              <span>
                Live data is stale{typeof ageMinutes === 'number' ? ` (${ageMinutes} min${ageMinutes === 1 ? '' : 's'} old)` : ''}. You can try refreshing.
              </span>
              <button
                onClick={handleManualRefresh}
                disabled={refreshing || loading || cooldownMs > 0}
                className={`ml-auto inline-flex items-center justify-center px-2.5 py-1.5 rounded ${(refreshing || cooldownMs > 0) ? 'bg-gray-600' : 'bg-purple-600 hover:bg-purple-700'} text-white text-xs transition-colors`}
              >
                <i className={`fas fa-sync-alt mr-1 ${refreshing ? 'animate-rotate' : ''}`}></i>
                {cooldownMs > 0 ? `Wait ${Math.ceil(cooldownMs/1000)}s` : 'Refresh'}
              </button>
            </div>
          )}

          {/* Header */}
          <header className="text-center py-6 animate-fade-in">
            <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold flex items-center justify-center gap-3 drop-shadow-lg">
              <span className="animate-trophy">🏆</span>
              HowBoutIt Preseason Survivor Pool
            </h1>
            <p className="mt-2 text-base sm:text-lg md:text-xl">Who is going to get the #1 Fucking Pick?!</p>
            <div className="mt-2 text-xs text-purple-200">
              Times shown are Eastern Time. <span className="ml-1" aria-label="Manual override indicator">Manual overrides are marked with 📝.</span>
            </div>
          </header>

          {/* Joke Ticker (Easter Egg) */}
          <div className="glass rounded-xl p-2 mb-4 flex items-center gap-2 text-sm animate-fade-in" aria-live="polite" aria-label="Live joke ticker">
            <span className="px-2 py-0.5 rounded-full bg-red-500/80 text-black text-xs font-bold">LIVE</span>
            <div 
              ref={tickerWrapRef} 
              className="relative overflow-hidden w-full cursor-pointer"
              onClick={reshuffleStream}
              onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); reshuffleStream(); } }}
              role="button"
              tabIndex={0}
              title="Click to reshuffle jokes"
            >
              <div 
                ref={tickerTrackRef}
                className="ticker-track text-amber-200"
              >
                {/* First copy (measured) */}
                <span ref={tickerTextRef} className="inline-block">
                  {streamJokes.map((j, idx) => (
                    <span key={`a${idx}`} className="pr-10">{j}</span>
                  ))}
                </span>
                {/* Second copy for seamless loop */}
                <span className="inline-block">
                  {streamJokes.map((j, idx) => (
                    <span key={`b${idx}`} className="pr-10">{j}</span>
                  ))}
                </span>
              </div>
            </div>
          </div>

          {/* Stats Overview */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 animate-fade-in">
            <div className="glass rounded-xl p-4 text-center">
              <div className="text-3xl font-bold text-yellow-300">{managers.length}</div>
              <div className="text-sm">Managers</div>
            </div>
            <div className="glass rounded-xl p-4 text-center">
              <div className="text-3xl font-bold text-green-400">{orderedManagers.filter(m => m.eliminationWeek > (calendar.totalWeeks || preseasonSchedule.length || 0)).length}</div>
              <div className="text-sm">Still Alive</div>
            </div>
            <div className="glass rounded-xl p-4 text-center">
              <div className="text-3xl font-bold text-red-400">{orderedManagers.filter(m => m.eliminationWeek <= (calendar.totalWeeks || preseasonSchedule.length || 0)).length}</div>
              <div className="text-sm">Eliminated</div>
            </div>
            <div className="glass rounded-xl p-4 text-center">
              <div className="text-3xl font-bold text-purple-400">{orderedManagers[0]?.name || '-'}</div>
              <div className="text-sm">Current Leader</div>
            </div>
          </div>

          {/* Draft Order Rules Legend */}
          <section className="glass rounded-2xl p-4 text-sm text-purple-100 animate-fade-in">
            <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">
              <i className="fas fa-info-circle"></i> Draft Order Rules
            </h2>
            <ul className="list-disc pl-5 space-y-1">
              <li><strong>Survivors first</strong>: Last manager standing gets #1 pick; other survivors follow (#2, #3, ...).</li>
              <li><strong>Same-week elimination</strong>: Higher <em>margin of victory that week</em> ranks higher.</li>
              <li><strong>Still tied</strong>: Higher <em>last year’s finish</em> ranks higher.</li>
              <li><strong>If all eliminated same week</strong>: Use that week’s margin, then last year’s finish.</li>
            </ul>
          </section>

          {/* Manager Cards */}
          <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {filteredManagers.map((mgr, mgrIdx) => {
              const derived = deriveElimination(mgr);
              const eliminationWeekComputed = derived.isEliminated ? derived.week : mgr.eliminationWeek;
              const isEliminated = derived.isEliminated;
              const isWinner = mgr.draftOrder === 1;
              const isOpen = expanded.has(mgr.name);
              const completedWeeks = calendar.completedWeeks || 0;
              const totalWeeks = calendar.totalWeeks || preseasonSchedule.length;
              const activeWeek = calendar.activeWeek || 0;
              const winsToDate = (mgr.picks || []).filter(p => p.week <= completedWeeks && p.result === 'W').length;
              const lossesToDate = (mgr.picks || []).filter(p => p.week <= completedWeeks && p.result === 'L').length;
              // Start from persisted totals through completed weeks
              let displayWins = winsToDate;
              let displayLosses = lossesToDate;
              // If eliminated this week but the week isn't counted in completedWeeks yet,
              // reflect that loss in the displayed record (e.g., show 0-1 instead of 0-0)
              if (isEliminated && eliminationWeekComputed && eliminationWeekComputed > completedWeeks) {
                const elimPick = (mgr.picks || []).find(p => p.week === eliminationWeekComputed && p.team);
                const elimOutcome = elimPick ? getTeamOutcomeForWeek(elimPick.team, elimPick.week) : null;
                if (elimOutcome) {
                  // If we somehow have a winner flag, respect it; otherwise default to a loss since eliminated
                  if (elimOutcome.isWinner === true) displayWins += 1; else displayLosses += 1;
                } else {
                  displayLosses += 1;
                }
              }
              let footerText = '';
              // Prioritize eliminated message
              if (isEliminated) {
                footerText = `Eliminated W${eliminationWeekComputed} • Record: ${displayWins}-${displayLosses}`;
              } else if (completedWeeks < totalWeeks) {
                // Season is underway or upcoming
                if (activeWeek > 0) {
                  // Check this manager's active-week pick state from live outcomes
                  const activePick = (mgr.picks || []).find(p => p.week === activeWeek && p.team);
                  const outcome = activePick ? getTeamOutcomeForWeek(activePick.team, activePick.week) : null;
                  if (outcome && outcome.state === 'in') {
                    footerText = `Week ${activeWeek} in progress • Record: ${winsToDate}-${lossesToDate}`;
                  } else if (outcome && outcome.state === 'post') {
                    // Some finals exist this week for this manager
                    const isTie = outcome.isTie === true || (outcome.score === outcome.oppScore);
                    const adjWins = winsToDate + (outcome.isWinner ? 1 : 0);
                    const adjLoss = lossesToDate + ((!outcome.isWinner && !isTie) ? 1 : 0);
                    footerText = `Through W${activeWeek}: ${adjWins}-${adjLoss}`;
                  } else if (completedWeeks === 0) {
                    footerText = `Season upcoming • First pick: W${activeWeek}`;
                  } else {
                    footerText = `Through W${completedWeeks}: ${winsToDate}-${lossesToDate} • Next: W${completedWeeks + 1}`;
                  }
                } else {
                  // No active week determined yet
                  footerText = 'Season upcoming • First pick: W1';
                }
              } else {
                // Season complete and manager survived
                footerText = `Survived all ${totalWeeks} weeks!`;
              }
              
              return (
                <div 
                  key={mgr.name} 
                  className={`glass rounded-2xl p-5 transition-all duration-300 transform hover:scale-[1.02] ${isEliminated ? 'eliminated' : ''} ${isWinner ? 'winner-glow' : ''} animate-fade-in`}
                  onClick={() => handleCardClick(mgr)}
                  style={{ animationDelay: `${mgrIdx * 0.1}s` }}
                >
                  <div className="flex justify-between items-start mb-2">
                    <div>
                      <div className="flex items-center gap-2">
                        <h2 className="text-xl font-bold">{mgr.name}</h2>
                        {isWinner && <span className="animate-trophy text-2xl">🏆</span>}
                        {isEliminated ? (
                          <span className="px-2 py-0.5 rounded-full text-xs bg-red-500/80">Eliminated W{eliminationWeekComputed}</span>
                        ) : (
                          <span className="px-2 py-0.5 rounded-full text-xs bg-green-600/80">Alive</span>
                        )}
                        {mgr.buyback && (
                          <span className="px-2 py-0.5 rounded-full text-xs bg-purple-600/80" title="Used buyback">Buyback</span>
                        )}
                      </div>
                      <p className="text-sm italic text-fuchsia-200">{mgr.teamLabel}</p>
                    </div>
                    <div className="flex items-start gap-2">
                      <button
                        onClick={() => toggleExpand(mgr.name)}
                        aria-expanded={isOpen}
                        aria-controls={`mgr-${mgrIdx}`}
                        aria-label={`Toggle ${mgr.name} details`}
                        className="md:hidden p-2 rounded-lg bg-white/10 hover:bg-white/20 transition-colors"
                        title="Toggle details"
                      >
                        <i className={`fas ${isOpen ? 'fa-chevron-up' : 'fa-chevron-down'}`}></i>
                      </button>
                      <div className="text-right">
                        <div className="flex items-center gap-1">
                          <span className="text-sm">Draft Pick:</span>
                          <span className={`font-bold text-lg ${isWinner ? 'text-yellow-300' : 'text-white'}`}>
                            #{mgr.draftOrder}
                          </span>
                        </div>
                        <div className="flex items-center gap-1" title={getMarginBreakdown(mgr)}>
                          <span className="text-sm">Margin:</span>
                          <span className="font-bold">{getCumulativeMargin(mgr)}</span>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  {/* Picks display */}
                  <div id={`mgr-${mgrIdx}`} className={`${isOpen ? 'block' : 'hidden'} md:block mb-4`}>
                    <h3 className="text-sm font-semibold mb-2 text-purple-200">Weekly Picks</h3>
                    <div className="flex flex-wrap gap-1 sm:gap-2">
                      {mgr.picks.map((pick, idx) => (
                        <div
                          key={idx}
                          className={(function(){
                            const outcome = pick.team ? getTeamOutcomeForWeek(pick.team, pick.week) : null;
                            const liveResult = outcome && outcome.state === 'post' ? (outcome.isTie ? null : (outcome.isWinner ? 'W' : 'L')) : null;
                            const effective = pick.result || liveResult;
                            const base = 'px-2 sm:px-3 py-1 rounded-full text-[11px] sm:text-xs font-medium flex items-center gap-1 whitespace-nowrap ';
                            if (effective === 'W') return base + 'bg-green-500/80';
                            if (effective === 'L') return base + 'bg-red-500/80';
                            return base + 'bg-gray-700/60';
                          })()}
                          title={(function(){
                            const outcome = pick.team ? getTeamOutcomeForWeek(pick.team, pick.week) : null;
                            const liveResult = outcome && outcome.state === 'post' ? (outcome.isTie ? null : (outcome.isWinner ? 'W' : 'L')) : null;
                            const effective = pick.result || liveResult;
                            let resText = 'Pending';
                            if (effective) resText = (effective === 'W' ? 'Win' : 'Loss');
                            else if (outcome && outcome.state === 'post' && outcome.isTie) resText = 'Tie';
                            const liveSuffix = (!pick.result && liveResult) ? ' (Live)' : '';
                            const manualSuffix = pick.manualResult ? ' (Manual override)' : '';
                            // Append stored note if available
                            let noteSuffix = '';
                            const matchup = pick.team ? findMatchupForTeam(pick.week, pick.team) : null;
                            const stored = matchup ? getStoredGame(pick.week, matchup) : null;
                            if (stored && stored.note) noteSuffix = ` • ${stored.note}`;
                            return `Week ${pick.week} - ${(pick.team || 'TBD')} - ${resText}${liveSuffix}${manualSuffix}${noteSuffix}`;
                          })()}
                        >
                          <span className="font-semibold">W{pick.week}</span>
                          <span className="inline max-w-[10rem] truncate sm:max-w-none" title={pick.team || 'TBD'}>{pick.team || 'TBD'}</span>
                          {(function(){
                            const locked = pick.team ? isPickLocked(pick.week, pick.team) : false;
                            if (!locked) return null;
                            return <span className="ml-0.5" title="Pick locked (game started)">🔒</span>;
                          })()}
                          {(function(){
                            const outcome = pick.team ? getTeamOutcomeForWeek(pick.team, pick.week) : null;
                            const liveResult = outcome && outcome.state === 'post' ? (outcome.isTie ? null : (outcome.isWinner ? 'W' : 'L')) : null;
                            const effective = pick.result || liveResult;
                            if (!effective) return null;
                            return (
                              <span className="font-bold">
                                {effective === 'W' ? '✓' : '✗'}
                              </span>
                            );
                          })()}
                          {pick.manualResult && (
                            <span className="text-xs ml-1" title="Manual override">📝</span>
                          )}
                          {(function(){
                            // Show buyback indicator next to the week they bought back in
                            if (!mgr || !mgr.buyback) return null;
                            const picksSorted = (mgr.picks || []).slice().sort((a,b) => (a.week||0) - (b.week||0));
                            const storedLoss = picksSorted.find(p => p && p.result === 'L');
                            let bbWeek = storedLoss ? storedLoss.week : null;
                            if (bbWeek == null) {
                              for (const p of picksSorted) {
                                if (!p || !p.team) continue;
                                const outcome = getTeamOutcomeForWeek(p.team, p.week);
                                if (outcome && outcome.state === 'post' && !outcome.isWinner && !outcome.isTie) { bbWeek = p.week; break; }
                              }
                            }
                            if (bbWeek === pick.week) {
                              return (
                                <span
                                  className="ml-1 px-2 py-0.5 rounded-full bg-yellow-400 text-black font-bold uppercase text-[10px]"
                                  title="Buyback week"
                                  aria-label="Buyback week"
                                >
                                  Buy Back Bitch
                                </span>
                              );
                            }
                            return null;
                          })()}
                        </div>
                      ))}
                    </div>
                    {/* Collapsible per-week margins table */}
                    <div className="mt-3">
                      <button
                        onClick={(e) => { e.stopPropagation(); toggleBreakdown(mgr.name); }}
                        className="px-2 py-1 rounded bg-white/10 hover:bg-white/20 text-xs flex items-center gap-1"
                        aria-expanded={openBreakdowns.has(mgr.name)}
                        aria-controls={`br-${mgrIdx}`}
                        title="Toggle margin breakdown"
                      >
                        <i className={`fas ${openBreakdowns.has(mgr.name) ? 'fa-chevron-up' : 'fa-chevron-down'}`}></i>
                        Margins breakdown
                      </button>
                      {openBreakdowns.has(mgr.name) && (
                        <div id={`br-${mgrIdx}`} className="mt-2 overflow-x-auto">
                          <table className="w-full text-xs">
                            <thead className="bg-purple-800/30">
                              <tr>
                                <th className="p-1 text-left">Week</th>
                                <th className="p-1 text-left">Team</th>
                                <th className="p-1 text-left">Result</th>
                                <th className="p-1 text-left">Margin</th>
                                <th className="p-1 text-left">Running Total</th>
                                <th className="p-1 text-left">Note</th>
                                <th className="p-1 text-left">Lock</th>
                              </tr>
                            </thead>
                            <tbody>
                              {(function(){
                                let runningTotal = 0;
                                return [...mgr.picks].sort((a,b)=>Number(a.week)-Number(b.week)).map((p, i) => {
                                  const wk = Number(p.week);
                                  if (!wk || !p.team) return null;
                                  if (isEliminated && wk > Number(eliminationWeekComputed)) return null;
                                  const out = getTeamOutcomeForWeek(p.team, wk);
                                  let diff = 0, res = '—', isLoss = false, isWin = false, isTie = false;
                                  if (out && out.state === 'post') {
                                    diff = (out.score - out.oppScore) || 0;
                                    isTie = !!out.isTie;
                                    isWin = out.isWinner && !isTie;
                                    isLoss = !out.isWinner && !isTie;
                                  } else {
                                    if (typeof p.margin === 'number') diff = p.margin;
                                    isWin = p.result === 'W';
                                    isLoss = p.result === 'L';
                                    isTie = p.result === 'T';
                                  }
                                  if (isWin) res = 'W'; else if (isLoss) res = 'L'; else if (isTie) res = 'T'; else res = '—';
                                  // Only add to running total for decided games (W/L). Tie contributes 0.
                                  if (res === 'W' || res === 'L') runningTotal += diff || 0;
                                  const matchup = findMatchupForTeam(wk, p.team);
                                  const stored = matchup ? getStoredGame(wk, matchup) : null;
                                  const note = stored && stored.note ? stored.note : (isTie ? 'Tie' : '');
                                  const locked = isPickLocked(wk, p.team);
                                  return (
                                    <tr key={`row-${wk}-${i}`} className={i % 2 === 0 ? 'bg-purple-700/20' : 'bg-purple-700/10'}>
                                      <td className="p-1">W{wk}</td>
                                      <td className="p-1">{p.team}</td>
                                      <td className="p-1">{res}</td>
                                      <td className="p-1">{(res === 'W' || res === 'L' || res === 'T') ? diff : '—'}</td>
                                      <td className="p-1">{runningTotal}</td>
                                      <td className="p-1">{note || ''}</td>
                                      <td className="p-1">{locked ? '🔒' : ''}</td>
                                    </tr>
                                  );
                                });
                              })()}
                            </tbody>
                          </table>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {/* Status indicator */}
                  <div className={`${isOpen ? 'flex' : 'hidden'} md:flex justify-between items-center mt-2 pt-3 border-t border-white/10`}>
                    <div className="text-sm">
                      {isEliminated ? (
                        <span className="text-red-400 font-medium flex items-center gap-1">
                          <i className="fas fa-skull"></i> Eliminated Week {eliminationWeekComputed}
                        </span>
                      ) : (
                        <span className="text-green-400 font-medium flex items-center gap-1">
                          <i className="fas fa-heart animate-pulse-slow"></i> Still Alive
                        </span>
                      )}
                    </div>
                    <div className="text-xs text-gray-300">{footerText}</div>
                  </div>
                </div>
              );
            })}
          </section>

          {/* Chart Section */}
          <section className="glass rounded-2xl p-5 animate-fade-in">
            <div className="flex items-center justify-between mb-2">
              <h2 className="text-xl font-semibold flex items-center gap-2">
                <i className="fas fa-chart-bar"></i> Survival Progress
              </h2>
              <button
                onClick={() => setChartOpen(o => !o)}
                aria-expanded={chartOpen}
                aria-controls="survival-chart"
                className="px-3 py-1.5 rounded-lg bg-white/10 hover:bg-white/20 transition-colors"
                aria-label="Toggle survival progress chart"
              >
                <span className="hidden sm:inline">{chartOpen ? 'Hide' : 'Show'}</span>
                <i className={`sm:ml-2 fas ${chartOpen ? 'fa-chevron-up' : 'fa-chevron-down'}`}></i>
              </button>
            </div>
            {chartOpen && (
              <div id="survival-chart" className="relative h-64">
                <canvas ref={chartRef} className="w-full h-full" />
              </div>
            )}
          </section>

          {/* Preseason Schedule */}
          <section className="glass rounded-2xl p-5 overflow-auto animate-fade-in">
            <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
              <i className="fas fa-calendar-alt"></i> Preseason Schedule (Weeks 1–3)
            </h2>
            {/* Desktop table */}
            <div className="hidden md:block overflow-x-auto">
              <table className="w-full text-sm">
                <thead className="bg-purple-800/40">
                  <tr>
                    <th className="p-2">Week</th>
                    <th className="p-2">Date</th>
                    <th className="p-2">Time (ET)</th>
                    <th className="p-2 text-left">Matchup</th>
                    <th className="p-2 text-left">Managers with Pick</th>
                  </tr>
                </thead>
                <tbody>
                  {preseasonSchedule.flatMap(week => 
                    week.games.map((game, idx) => {
                      // Extract team names from matchup
                      const teams = game.matchup.split(' at ');
                      const awayTeam = teams[0];
                      const homeTeam = teams[1];
                      const score = scoreboardMap.get(game.matchup);
                      
                      // Find managers who have picked either team for this week
                      const managersWithPick = managers.filter(manager => {
                        const pick = manager.picks.find(p => p.week === week.week);
                        return pick && pick.team && (pick.team.trim() !== '' && (pick.team === awayTeam || pick.team === homeTeam));
                      });
                      
                      // Check stored game results first, then live scores, then fallback logic
                      let displayTime = `${game.time}`;
                      
                      // Look for stored game result for this week
                      const weekKey = `week${week.week}`;
                      const storedGame = gameResults[weekKey] && gameResults[weekKey].find(g => g.matchup === game.matchup);
                      
                      if (storedGame) {
                        displayTime = `Final ${storedGame.awayScore}–${storedGame.homeScore}`;
                      } else if (score && score.state === 'post') {
                        displayTime = `Final ${score.awayScore}–${score.homeScore}`;
                      } else {
                        // Check if any manager has a completed result for either team in this week
                        const completedPicks = managersWithPick.filter(mgr => {
                          const pick = mgr.picks.find(p => p.week === week.week);
                          return pick && (pick.result === 'W' || pick.result === 'L') && pick.margin !== undefined;
                        });
                        
                        if (completedPicks.length > 0) {
                          displayTime = `Final`;
                        }
                      }
                      // Determine lock and note status
                      const outA = getTeamOutcomeForWeek(awayTeam, week.week);
                      const outB = getTeamOutcomeForWeek(homeTeam, week.week);
                      const locked = (outA && outA.state !== 'pre') || (outB && outB.state !== 'pre');
                      let noteText = '';
                      if (storedGame && storedGame.note) noteText = storedGame.note;
                      else if ((storedGame && storedGame.awayScore === storedGame.homeScore) || (score && score.state === 'post' && score.awayScore === score.homeScore)) noteText = 'Tie';
                      
                      return (
                        <tr key={`${week.week}-${idx}`} className={idx % 2 === 0 ? 'bg-purple-700/30' : 'bg-purple-700/20'}>
                          <td className="p-2 text-center">{week.week}</td>
                          <td className="p-2 text-center">{game.date}</td>
                          <td className="p-2 text-center">
                            <span>{displayTime}</span>
                            {locked && <span className="ml-1" title="Kickoff passed (locked)">🔒</span>}
                          </td>
                          <td className="p-2">
                            <div className="flex items-center gap-2">
                              <span className="font-medium">{awayTeam}</span>
                              <span className="text-gray-400">@</span>
                              <span className="font-medium">{homeTeam}</span>
                              {noteText && (
                                <i className="fas fa-circle-info text-amber-300 ml-1" title={noteText}></i>
                              )}
                            </div>
                          </td>
                          <td className="p-2">
                            {managersWithPick.length > 0 ? (
                              <div className="flex flex-wrap gap-1">
                                {managersWithPick.map((manager, mgrIdx) => {
                                  const pick = manager.picks.find(p => p.week === week.week);
                                  const outcome = pick && pick.team ? getTeamOutcomeForWeek(pick.team, week.week) : null;
                                  let cls = 'bg-gray-500/60';
                                  
                                  // Check live outcome first, then fallback to stored result
                                  if (outcome && outcome.state === 'post') {
                                    cls = outcome.isWinner ? 'bg-green-500/60' : 'bg-red-500/60';
                                  } else if (pick && (pick.result === 'W' || pick.result === 'L')) {
                                    cls = pick.result === 'W' ? 'bg-green-500/60' : 'bg-red-500/60';
                                  }
                                  
                                  return (
                                    <span 
                                      key={mgrIdx}
                                      className={`px-2 py-1 rounded-full text-xs font-medium ${cls}`}
                                      title={`${manager.name} - ${manager.teamLabel}`}
                                    >
                                      {manager.name}
                                      {(function(){
                                        const l = pick && pick.team ? isPickLocked(week.week, pick.team) : false;
                                        return l ? <span className="ml-1" title="Pick locked">🔒</span> : null;
                                      })()}
                                    </span>
                                  );
                                })}
                              </div>
                            ) : (
                              <span className="text-gray-400 text-sm">No picks</span>
                            )}
                          </td>
                        </tr>
                      );
                    })
                  )}
                </tbody>
              </table>
            </div>
             {/* Mobile grouped by week with toggles */}
             <div className="md:hidden space-y-3">
               {preseasonSchedule.map(week => {
                 const isOpen = openWeeks.has(week.week);
                 return (
                   <div key={`week-${week.week}`} className="rounded-xl bg-indigo-900/20">
                    <button
                      onClick={() => toggleWeek(week.week)}
                      className="w-full flex items-center justify-between p-3"
                      aria-expanded={isOpen}
                      aria-controls={`week-${week.week}-games`}
                      aria-label={`Toggle week ${week.week} games`}
                    >
                      <span className="font-semibold">Week {week.week}</span>
                      <i className={`fas ${isOpen ? 'fa-chevron-up' : 'fa-chevron-down'}`}></i>
                    </button>
                    {isOpen && (
                      <div id={`week-${week.week}-games`} className="px-3 pb-3 space-y-2">
                        {week.games.map((game, idx) => {
                          const teams = game.matchup.split(' at ');
                          const awayTeam = teams[0];
                          const homeTeam = teams[1];
                          const score = scoreboardMap.get(game.matchup);
                          const managersWithPick = managers.filter(manager => {
                            const pick = manager.picks.find(p => p.week === week.week);
                            return pick && pick.team && (pick.team.trim() !== '' && (pick.team === awayTeam || pick.team === homeTeam));
                          });
                          
                          // Check stored game results first, then live scores, then fallback logic
                          let displayTime = `${game.time} ET`;
                          
                          // Look for stored game result for this week
                          const weekKey = `week${week.week}`;
                          const storedGame = gameResults[weekKey] && gameResults[weekKey].find(g => g.matchup === game.matchup);
                          
                          if (storedGame) {
                            displayTime = `Final ${storedGame.awayScore}–${storedGame.homeScore}`;
                          } else if (score && score.state === 'post') {
                            displayTime = `Final ${score.awayScore}–${score.homeScore}`;
                          } else {
                            // Check if any manager has a completed result for either team in this week
                            const completedPicks = managersWithPick.filter(mgr => {
                              const pick = mgr.picks.find(p => p.week === week.week);
                              return pick && (pick.result === 'W' || pick.result === 'L') && pick.margin !== undefined;
                            });
                            
                            if (completedPicks.length > 0) {
                              displayTime = `Final`;
                            }
                          }
                          // Determine lock and note
                          const outA = getTeamOutcomeForWeek(awayTeam, week.week);
                          const outB = getTeamOutcomeForWeek(homeTeam, week.week);
                          const locked = (outA && outA.state !== 'pre') || (outB && outB.state !== 'pre');
                          let noteText = '';
                          if (storedGame && storedGame.note) noteText = storedGame.note;
                          else if ((storedGame && storedGame.awayScore === storedGame.homeScore) || (score && score.state === 'post' && score.awayScore === score.homeScore)) noteText = 'Tie';
                          
                          return (
                            <div key={`${week.week}-m-${idx}`} className="rounded-lg bg-indigo-900/30 p-3">
                              <div className="flex items-center justify-between text-sm">
                                <div className="font-semibold">
                                  <span>{displayTime}</span>
                                  {locked && <span className="ml-1" title="Kickoff passed (locked)">🔒</span>}
                                </div>
                                <div className="text-xs text-purple-200">{game.date}</div>
                              </div>
                              <div className="mt-1 font-medium">
                                {awayTeam} <span className="text-gray-400">@</span> {homeTeam}
                                {noteText && (
                                  <i className="fas fa-circle-info text-amber-300 ml-1" title={noteText}></i>
                                )}
                              </div>
                              {managersWithPick.length > 0 ? (
                                <div className="mt-2 flex flex-wrap gap-1">
                                  {managersWithPick.map((manager, mgrIdx) => {
                                    const pick = manager.picks.find(p => p.week === week.week);
                                    const outcome = pick && pick.team ? getTeamOutcomeForWeek(pick.team, week.week) : null;
                                    let cls = 'bg-gray-500/60';
                                    
                                    // Check live outcome first, then fallback to stored result
                                    if (outcome && outcome.state === 'post') {
                                      cls = outcome.isWinner ? 'bg-green-500/60' : 'bg-red-500/60';
                                    } else if (pick && (pick.result === 'W' || pick.result === 'L')) {
                                      cls = pick.result === 'W' ? 'bg-green-500/60' : 'bg-red-500/60';
                                    }
                                    
                                    return (
                                      <span key={mgrIdx} className={`px-2 py-0.5 rounded-full text-[11px] ${cls}`}>
                                        {manager.name}
                                        {(function(){
                                          const l = pick && pick.team ? isPickLocked(week.week, pick.team) : false;
                                          return l ? <span className="ml-1" title="Pick locked">🔒</span> : null;
                                        })()}
                                      </span>
                                    );
                                  })}
                                </div>
                              ) : (
                                <div className="mt-2 text-gray-300 text-xs">No picks</div>
                              )}
                            </div>
                          );
                        })}
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </section>

          {/* Live Scoreboard Section */}
          <section className="glass rounded-2xl p-5 overflow-auto animate-fade-in">
            <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
              <i className="fas fa-football-ball"></i> Live Scoreboard
              {games.length > 0 && (
                <span className="ml-2 px-2 py-1 bg-red-500 text-xs rounded-full live-indicator">
                  LIVE
                </span>
              )}
            </h2>
            {games && games.length > 0 ? (
              <>
                {/* Desktop table */}
                <div className="hidden md:block overflow-x-auto">
                  <table className="w-full text-sm">
                    <thead className="bg-indigo-800/40">
                      <tr>
                        <th className="p-2 text-left">Matchup</th>
                        <th className="p-2 text-center">Score</th>
                        <th className="p-2 text-center">Status</th>
                      </tr>
                    </thead>
                    <tbody>
                      {gamesSorted.map((ev, idx) => {
                        const comp = ev.competitions && ev.competitions[0];
                        if (!comp) return null;
                        const teams = comp.competitors;
                        const home = teams.find(t => t.homeAway === 'home');
                        const away = teams.find(t => t.homeAway === 'away');
                        const statusDesc = ev.status && ev.status.type && ev.status.type.shortDetail;
                        const state = ev.status && ev.status.type && ev.status.type.state;
                        const isCompleted = state === 'post';
                        
                        return (
                          <tr key={idx} className={idx % 2 === 0 ? 'bg-indigo-700/30' : 'bg-indigo-700/20'}>
                            <td className="p-2">
                              <div className="flex items-center gap-2">
                                <div>{away.team.displayName}</div>
                                <div className="text-gray-400">@</div>
                                <div>{home.team.displayName}</div>
                              </div>
                            </td>
                            <td className="p-2 text-center font-mono">
                              {away.score} – {home.score}
                            </td>
                            <td className="p-2 text-center">
                              <span className={`px-2 py-1 rounded-full text-xs ${
                                isCompleted
                                  ? 'bg-green-500/80'
                                  : (state === 'in'
                                      ? 'bg-red-500/80 animate-pulse-slow'
                                      : 'bg-yellow-500/80')
                              }`}>
                                {statusDesc}
                              </span>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
                {/* Mobile cards */}
                <div className="md:hidden space-y-3">
                  {gamesSorted.map((ev, idx) => {
                    const comp = ev.competitions && ev.competitions[0];
                    if (!comp) return null;
                    const teams = comp.competitors;
                    const home = teams.find(t => t.homeAway === 'home');
                    const away = teams.find(t => t.homeAway === 'away');
                    const statusDesc = ev.status && ev.status.type && ev.status.type.shortDetail;
                    const state = ev.status && ev.status.type && ev.status.type.state;
                    const isCompleted = state === 'post';
                    return (
                      <div key={`m-${idx}`} className="rounded-lg bg-indigo-900/30 p-3">
                        <div className="flex items-center justify-between">
                          <div className={`text-sm px-2 py-0.5 rounded-full font-semibold ${isCompleted ? 'bg-green-300 text-black' : (state === 'in' ? 'bg-red-300 text-black' : 'bg-yellow-300 text-black')}`}>{isCompleted ? 'Final' : (state === 'in' ? 'Live' : 'Scheduled')}</div>
                        </div>
                        <div className="mt-2">
                          <div className="flex justify-between text-sm">
                            <span className="font-medium">{away.team.displayName}</span>
                            <span className="font-mono">{away.score}</span>
                          </div>
                          <div className="text-center text-gray-400 text-xs">@</div>
                          <div className="flex justify-between text-sm">
                            <span className="font-medium">{home.team.displayName}</span>
                            <span className="font-mono">{home.score}</span>
                          </div>
                          {statusDesc && (
                            <div className="mt-1 text-sm font-mono text-purple-100">{statusDesc}</div>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </>
            ) : (
              <div className="text-center py-8">
                <i className="fas fa-info-circle text-3xl text-purple-300 mb-2"></i>
                <p className="text-purple-200">No games in progress or data unavailable.</p>
              </div>
            )}
          </section>

          {/* Mobile Refresh FAB */}
          <button
            onClick={loadData}
            disabled={refreshing || loading}
            aria-label="Refresh data"
            aria-busy={refreshing}
            className={`sm:hidden fixed right-[calc(1rem+env(safe-area-inset-right))] bottom-[calc(1rem+env(safe-area-inset-bottom))] p-4 rounded-full shadow-lg ${refreshing ? 'bg-gray-600' : 'bg-purple-600 hover:bg-purple-700'} transition-colors`}
            title="Refresh data"
          >
            <i className={`fas fa-sync-alt ${refreshing ? 'animate-rotate' : ''}`}></i>
          </button>

          {/* Footer */}
          <footer className="text-center py-6 text-sm text-purple-300 border-t border-white/10">
            <p>NFL Preseason Survivor Pool • Draft order determined by survival and margin of victory</p>
            <p className="mt-1">Admin: <a href="admin.html" className="text-purple-200 hover:text-white">Manage Pool</a></p>
          </footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
  <script>
    // Register service worker for PWA installability and offline fallback
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch((err) => {
          console.warn('Service worker registration failed:', err);
        });
      });
    }
  </script>
</body>
</html>
